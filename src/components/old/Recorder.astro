<video
    autoplay
    muted class="w-full h-full bg-gray-200 rounded"
></video>

<script>
let mediaRecorder: MediaRecorder | null = null;
let recordedChunks = [] as Array<BlobPart>;
let stream: MediaStream | null = null; // Store stream globally/in scope to stop tracks later

const startBtn = document.getElementById("start-recording-btn");
const stopBtn = document.getElementById("stop-recording-btn");
const videoElement = document.querySelector("video");

function getSupportedMimeType() {
  const types = [
    'video/webm; codecs=vp9,opus', // High quality, modern
    'video/webm; codecs=vp8,opus', // Good fallback
    'video/webm', // Generic WebM
    'video/mp4' // If you want MP4 (less common for recorder)
  ];

  for (const type of types) {
    if (MediaRecorder.isTypeSupported(type)) {
      return type;
    }
  }
  // Fallback if no specific type is supported (unlikely)
  return 'video/webm';
}

/**
 * Requests media access, sets up the video preview, and starts the recorder.
 */
async function startRecording() {
  if (!videoElement) return;

  try {
    // 1. Request access for both video and audio
    stream = await navigator.mediaDevices.getUserMedia({video: true, audio: true});

    // 2. Set up the local video preview
    videoElement.srcObject = stream;
    // videoElement.play() is often not needed if 'autoplay' is set, but it's safe.
    videoElement.play();

    // 3. Initialize MediaRecorder with the stream (which includes both tracks)
    // You can specify the MIME type if needed, e.g., 'video/webm; codecs=vp9,opus'
    const mimeType = getSupportedMimeType();
    console.log("Using MIME type for recording:", mimeType);
    mediaRecorder = new MediaRecorder(stream, { mimeType });

    mediaRecorder.ondataavailable = (event) => {
      // Data is correctly pushed to the array, which will include audio data
      if (event.data.size > 0) recordedChunks.push(event.data);
    };

    mediaRecorder.start();
    console.log("Recording started.");

    // Update button states
    if (startBtn) startBtn.disabled = true;
    if (stopBtn) stopBtn.disabled = false;

  } catch (error) {
    // Handle permissions denial or device issues gracefully
    console.error("Error accessing media devices:", error);
    alert(`Could not start recording. Please check your camera/microphone permissions. Error: ${error.name}`);
  }
}

/**
 * Stops the recorder, handles the data, and uploads the video/audio blob.
 */
function stopRecording() {
  if(!mediaRecorder || mediaRecorder.state === 'inactive') return;

  mediaRecorder.stop();
  console.log("Recording stopping...");

  // Update button states
  if (startBtn) startBtn.disabled = false;
  if (stopBtn) stopBtn.disabled = true;

  mediaRecorder.onstop = async () => {
    // Stop all tracks to release the camera/mic (GOOD PRACTICE)
    if (stream) {
      stream.getTracks().forEach(track => track.stop());
      videoElement.srcObject = null; // Clear the video preview
      stream = null;
    }

    // 1. Create the Blob (includes video and audio)
    const blob = new Blob(recordedChunks, {type: "video/webm"});
    console.log("Recording stopped. Blob size:", blob.size);

    // 2. Prepare for upload
    const formData = new FormData();
    formData.append("video", blob, "recording.webm");

    // 3. Upload
    try {
      const response = await fetch("/api/upload-video", {
        method: "POST",
        body: formData,
      });

      if (response.ok) {
        console.log("Video and Audio uploaded successfully!");
        // Optionally, clear the recorded chunks after a successful upload
        recordedChunks = [];
      } else {
        console.error("Upload failed with status:", response.status);
      }
    } catch (e) {
      console.error("Error during upload:", e);
    }
  };
}

/**
 * Attaches event listeners to the buttons.
 */
function addListeners() {
  const startBtn = document.getElementById("start-recording-btn");
  const stopBtn = document.getElementById("stop-recording-btn");
  if (startBtn) startBtn.onclick = startRecording;
  if (stopBtn) stopBtn.onclick = stopRecording;
}

document.addEventListener("DOMContentLoaded", addListeners);
document.addEventListener("htmx:afterSwap", addListeners);
</script>